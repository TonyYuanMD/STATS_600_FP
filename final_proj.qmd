---
title: "final_proj"
format: html
editor: source
---

```{r lib, echo=FALSE}
library(ggplot2)
library(dplyr)
library(tidyverse)
library(lme4)
library(reshape2)
library(corrplot)
library(inspectdf)
```

# Exploratory Data Analysis

```{r prep, echo=FALSE}
data <- read.csv("data.csv")
non_fac <- c("SEQN", "RIDAGEYR", "INDFMPIR", "BMXBMI", "DBD895", "DBD905", "DBD910")

# Negate to select factor variables (columns NOT in non_factor_vars)
data <- data |>
  mutate(across(!all_of(non_fac), as.factor))
```

```{r EDA, echo=FALSE}
# Step 2: Reshape data into a long format for ggplot
# Gather categorical variables into a key-value pair structure
long_data <- data %>%
  select(! all_of(non_fac)) %>%
  pivot_longer(cols = everything(), names_to = "Variable", values_to = "Category")

# Step 3: Calculate proportions for each category in each variable
prop_data <- long_data %>%
  group_by(Variable, Category) %>%
  summarise(Count = n(), .groups = "drop") %>%
  group_by(Variable) %>%
  mutate(Proportion = Count / sum(Count)) %>%
  arrange(Variable, desc(Category)) %>% # Arrange for consistent stacking
  mutate(Cumulative = cumsum(Proportion) - Proportion / 2) # Position for labels

# Step 4: Create stacked bar chart with proportion labels
ggplot(prop_data, aes(x = Variable, y = Proportion, fill = Category)) +
  geom_bar(stat = "identity", position = "stack", color = "black") +
  geom_text(aes(label = scales::percent(Proportion, accuracy = 1), y = Cumulative),
            color = "black", size = 3) + # Add labels on the bars
  labs(
    title = "Proportions of Categories for Each Categorical Variable",
    x = "Categorical Variables",
    y = "Proportion"
  ) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  scale_fill_brewer(palette = "Pastel1")
```

```{r, echo=FALSE}
# 2. Correlation Heatmap for Numeric Variables
# Select numeric columns
numeric_data <- data[sapply(data, is.numeric)]

# Compute correlations
cor_matrix <- cor(numeric_data, use = "complete.obs")

# Plot heatmap
corrplot(cor_matrix, method = "color", tl.col = "black", tl.srt = 45, addCoef.col = "black")

# 3. Distribution of Numeric Variables
# Example: Histogram for a single numeric variable (e.g., BMXBMI)
ggplot(data, aes(x = BMXBMI)) +
  geom_histogram(fill = "lightblue", color = "black", bins = 30) +
  labs(title = "Histogram of BMXBMI", x = "BMXBMI", y = "Frequency") +
  theme_minimal()

```

# LASSO Regression

```{r}
# Load the packages we need.
library(tidyverse)
library(glmnet)
library(conflicted)

# Set conflict functions to require explicit calls.
conflict_prefer("filter", "dplyr")
conflict_prefer("lag", "dplyr")

# Load the data.
data <- read.csv("data.csv")

# Categorizes variables.
nominal_vars <- c("RIAGENDR", "RIDRETH1", "DMDBORN4", "DMDMARTZ", "SMQ020", 
                  "DIQ010", "MCQ010", "MCQ053", "MCQ092")
ordinal_vars <- c("DMDEDUC2", "INDFMMPC", "ALQ111", "ALQ121", "ALQ151", 
                  "BPQ020", "BPQ080", "DBQ700", "DBQ197")
continuous_vars <- c("RIDAGEYR", "BMXBMI", "INDFMPIR", "DBD895", "DBD905", "DBD910")

# Convert unordered variables to factor type.
data <- data %>%
  mutate(across(all_of(nominal_vars), as.factor))

# Keep ordered categorical variables as numeric type.
data <- data %>%
  mutate(across(all_of(ordinal_vars), ~ as.numeric(.)))

# Separate continuous vaiables.
X_continuous <- data %>% select(all_of(continuous_vars))

# Standardize continuous variables.
X_continuous_scaled <- scale(X_continuous)

# Perform dummy variables encoding for unordered factor variables.
X_nominal_encoded <- model.matrix(~ . - 1, data = data %>% select(all_of(nominal_vars)))

# Convert ordered categorical variables to factors and set levels.
data <- data %>%
  mutate(across(all_of(ordinal_vars), ~ as.ordered(.x)))

# Combine continuous variables, ordered categorical variables and dummy variables.
X_processed <- cbind(X_continuous_scaled, data %>% select(all_of(ordinal_vars)), X_nominal_encoded)

# Convert X_processed into a standard matrix.
X_processed <- as.matrix(X_processed)

# Ensure all data in the matrix is of numeric type.
X_processed <- apply(X_processed, 2, as.numeric)

# Extract the dependent variable.
y <- data$depressed


# Apply the LASSO.
lasso_model <- glmnet(X_processed, y,
                family = 'binomial', 
                intercept = FALSE, alpha = 1)

# Extract coefficient paths from the LASSO model.
lasso_coefs <- as.matrix(lasso_model$beta)
lambda_vals <- lasso_model$lambda

# Convert the coefficient matrix to a long format for ggplot.
lasso_df <- as.data.frame(t(lasso_coefs)) %>%
  mutate(log_lambda = log(lambda_vals)) %>%
  pivot_longer(cols = -log_lambda, names_to = "variable", values_to = "coefficient")

library(scales)  # For muted color palettes

# Generate a muted color palette
num_variables <- length(unique(lasso_df$variable))
muted_colors <- muted(hue_pal()(num_variables))

# Plot LASSO paths using ggplot.
ggplot(lasso_df, aes(x = log_lambda, y = coefficient, color = variable)) +
  geom_line(size = 1) +
  scale_color_manual(values = rainbow(length(unique(lasso_df$variable)))) +  
  labs(
    title = "LASSO Regularization Paths",
    x = "Log(Lambda)",
    y = "Coefficients"
  ) +
  theme_minimal() +
  theme(plot.title = element_text(hjust = 0.5),
        legend.position = "none") 



# Visualization.
selected_features %>%
  filter(Variable != "(Intercept)") %>%
  ggplot(aes(x = reorder(Variable, Coefficient), y = Coefficient)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  coord_flip() +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  labs(
    title = "LASSO Selected Variables and Coefficients",
    x = "Variable",
    y = "Coefficient"
  ) +
  theme_minimal()

#summary(lasso_model)


# Run cross-validation with select lambda.
mod_cv <- cv.glmnet(x=X_processed, y=y, family="binomial", # Default:nfolds = 10
                    intercept = F, alpha=1)

plot(mod_cv) 









```

```{r}

```
